{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/Acdev/Documents/pagina-checkout/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProxyMiddleware = void 0;\n\nconst httpProxy = require(\"http-proxy\");\n\nconst config_factory_1 = require(\"./config-factory\");\n\nconst contextMatcher = require(\"./context-matcher\");\n\nconst handlers = require(\"./_handlers\");\n\nconst logger_1 = require(\"./logger\");\n\nconst PathRewriter = require(\"./path-rewriter\");\n\nconst Router = require(\"./router\");\n\nclass HttpProxyMiddleware {\n  constructor(context, opts) {\n    var _this = this;\n\n    this.logger = logger_1.getInstance();\n    this.wsInternalSubscribed = false;\n    this.serverOnCloseSubscribed = false; // https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript#red-flags-for-this\n\n    this.middleware = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (req, res, next) {\n        var _a, _b;\n\n        if (_this.shouldProxy(_this.config.context, req)) {\n          try {\n            const activeProxyOptions = yield _this.prepareProxyRequest(req);\n\n            _this.proxy.web(req, res, activeProxyOptions);\n          } catch (err) {\n            next(err);\n          }\n        } else {\n          next();\n        }\n        /**\n         * Get the server object to subscribe to server events;\n         * 'upgrade' for websocket and 'close' for graceful shutdown\n         *\n         * NOTE:\n         * req.socket: node >= 13\n         * req.connection: node < 13 (Remove this when node 12/13 support is dropped)\n         */\n\n\n        const server = (_b = (_a = req.socket) !== null && _a !== void 0 ? _a : req.connection) === null || _b === void 0 ? void 0 : _b.server;\n\n        if (server && !_this.serverOnCloseSubscribed) {\n          server.on('close', () => {\n            _this.logger.info('[HPM] server close signal received: closing proxy server');\n\n            _this.proxy.close();\n          });\n          _this.serverOnCloseSubscribed = true;\n        }\n\n        if (_this.proxyOptions.ws === true) {\n          // use initial request to access the server object to subscribe to http upgrade event\n          _this.catchUpgradeRequest(server);\n        }\n      });\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.catchUpgradeRequest = server => {\n      if (!this.wsInternalSubscribed) {\n        server.on('upgrade', this.handleUpgrade); // prevent duplicate upgrade handling;\n        // in case external upgrade is also configured\n\n        this.wsInternalSubscribed = true;\n      }\n    };\n\n    this.handleUpgrade = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (req, socket, head) {\n        if (_this.shouldProxy(_this.config.context, req)) {\n          const activeProxyOptions = yield _this.prepareProxyRequest(req);\n\n          _this.proxy.ws(req, socket, head, activeProxyOptions);\n\n          _this.logger.info('[HPM] Upgrading to WebSocket');\n        }\n      });\n\n      return function (_x4, _x5, _x6) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    /**\n     * Determine whether request should be proxied.\n     *\n     * @private\n     * @param  {String} context [description]\n     * @param  {Object} req     [description]\n     * @return {Boolean}\n     */\n\n\n    this.shouldProxy = (context, req) => {\n      const path = req.originalUrl || req.url;\n      return contextMatcher.match(context, path, req);\n    };\n    /**\n     * Apply option.router and option.pathRewrite\n     * Order matters:\n     *    Router uses original path for routing;\n     *    NOT the modified path, after it has been rewritten by pathRewrite\n     * @param {Object} req\n     * @return {Object} proxy options\n     */\n\n\n    this.prepareProxyRequest = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (req) {\n        // https://github.com/chimurai/http-proxy-middleware/issues/17\n        // https://github.com/chimurai/http-proxy-middleware/issues/94\n        req.url = req.originalUrl || req.url; // store uri before it gets rewritten for logging\n\n        const originalPath = req.url;\n        const newProxyOptions = Object.assign({}, _this.proxyOptions); // Apply in order:\n        // 1. option.router\n        // 2. option.pathRewrite\n\n        yield _this.applyRouter(req, newProxyOptions);\n        yield _this.applyPathRewrite(req, _this.pathRewriter); // debug logging for both http(s) and websockets\n\n        if (_this.proxyOptions.logLevel === 'debug') {\n          const arrow = logger_1.getArrow(originalPath, req.url, _this.proxyOptions.target, newProxyOptions.target);\n\n          _this.logger.debug('[HPM] %s %s %s %s', req.method, originalPath, arrow, newProxyOptions.target);\n        }\n\n        return newProxyOptions;\n      });\n\n      return function (_x7) {\n        return _ref3.apply(this, arguments);\n      };\n    }(); // Modify option.target when router present.\n\n\n    this.applyRouter = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (req, options) {\n        let newTarget;\n\n        if (options.router) {\n          newTarget = yield Router.getTarget(req, options);\n\n          if (newTarget) {\n            _this.logger.debug('[HPM] Router new target: %s -> \"%s\"', options.target, newTarget);\n\n            options.target = newTarget;\n          }\n        }\n      });\n\n      return function (_x8, _x9) {\n        return _ref4.apply(this, arguments);\n      };\n    }(); // rewrite path\n\n\n    this.applyPathRewrite = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* (req, pathRewriter) {\n        if (pathRewriter) {\n          const path = yield pathRewriter(req.url, req);\n\n          if (typeof path === 'string') {\n            req.url = path;\n          } else {\n            _this.logger.info('[HPM] pathRewrite: No rewritten path found. (%s)', req.url);\n          }\n        }\n      });\n\n      return function (_x10, _x11) {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n\n    this.logError = (err, req, res, target) => {\n      var _a;\n\n      const hostname = ((_a = req.headers) === null || _a === void 0 ? void 0 : _a.host) || req.hostname || req.host; // (websocket) || (node0.10 || node 4/5)\n\n      const requestHref = `${hostname}${req.url}`;\n      const targetHref = `${target === null || target === void 0 ? void 0 : target.href}`; // target is undefined when websocket errors\n\n      const errorMessage = '[HPM] Error occurred while proxying request %s to %s [%s] (%s)';\n      const errReference = 'https://nodejs.org/api/errors.html#errors_common_system_errors'; // link to Node Common Systems Errors page\n\n      this.logger.error(errorMessage, requestHref, targetHref, err.code || err, errReference);\n    };\n\n    this.config = config_factory_1.createConfig(context, opts);\n    this.proxyOptions = this.config.options; // create proxy\n\n    this.proxy = httpProxy.createProxyServer({});\n    this.logger.info(`[HPM] Proxy created: ${this.config.context}  -> ${this.proxyOptions.target}`);\n    this.pathRewriter = PathRewriter.createPathRewriter(this.proxyOptions.pathRewrite); // returns undefined when \"pathRewrite\" is not provided\n    // attach handler to http-proxy events\n\n    handlers.init(this.proxy, this.proxyOptions); // log errors for debug purpose\n\n    this.proxy.on('error', this.logError); // https://github.com/chimurai/http-proxy-middleware/issues/19\n    // expose function to upgrade externally\n\n    this.middleware.upgrade = (req, socket, head) => {\n      if (!this.wsInternalSubscribed) {\n        this.handleUpgrade(req, socket, head);\n      }\n    };\n  }\n\n}\n\nexports.HttpProxyMiddleware = HttpProxyMiddleware;","map":null,"metadata":{},"sourceType":"script"}